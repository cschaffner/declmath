# -*- mode: perl; -*-

use LaTeXML::Package;
use strict;
use warnings;

use Data::Dumper qw/Dumper/;

RequirePackage('hyperref');

our %macroToCDName = ();
our %declarations = ();

our %uniqueNames = ();
sub uniqueName {
  my ($name) = @_;
  if (!defined $uniqueNames{$name}) {
    $uniqueNames{$name} = 1;
    return $name;
  }
  for (my $i = 1; ; $i++) {
    my $name1 = $name.$i;
    if (!defined $uniqueNames{$name1}) {
      $uniqueNames{$name1} = 1;
      return $name1;
    }
  }
}

RequireResource('declmath.css');
RequireResource('https://code.jquery.com/jquery-3.2.1.min.js');
RequireResource('declmath.js');

DefKeyVal('declare@keyval','macro','DefToken');
DefKeyVal('declare@keyval','argspec','{[Number][]}');
DefKeyVal('declare@keyval','code','');
DefKeyVal('declare@keyval','variantof','');
DefKeyVal('declare@keyval','variable',''); # true/false
DefKeyVal('declare@keyval','cd','');
DefKeyVal('declare@keyval','name','');

DefConstructorI('\@@@declmath@internal@xmlinfo','{}{}{}{}', sub {
 		  my ($document,$cdname,$placeholder,$description,$symbolindexlinks) = @_;
		  my $id = "symbolindexentry-".ToString($cdname);
 		  $document->openElement('ltx:para','xml:id'=>$id,'class'=>'symbolIndexEntry');
 		  $document->insertElement('ltx:p',$placeholder);
 		  $document->insertElement('ltx:p',$description);
 		  $document->insertElement('ltx:p',$symbolindexlinks);
 		  $document->closeElement('ltx:para');
 		});

sub kvAsBool {
  my ($val) = @_;
  return 0 unless defined $val;
  $val = ToString($val);
  return 0 if $val eq 'false';
  return 1 if $val eq 'true';
  die "Expected true/false";
};

DefPrimitive('\declare RequiredKeyVals:declare@keyval', sub {
	       my ($stomach, $kv) = @_;
	       my $macro = $kv->getValue('macro');
	       my $macroStr = ToString($macro);
	       my $argspec = ToString($kv->getValue('argspec'));
	       my $code = $kv->getValue('code');
	       my $placeholder = $kv->getValue('placeholder');
	       if (!defined $placeholder and $argspec eq '') {
		 $placeholder = $macro; }
	       my $description = $kv->getValue('description');
	       my $variantof = $kv->getValue('variantof');
	       my $variantofStr = ToString($variantof);
	       my $variable = kvAsBool($kv->getValue('variable'));
	       
	       my $cd = $kv->getValue('cd'); $cd = ToString($cd) if defined $cd;
	       my $name = $kv->getValue('name'); $name = ToString($name) if defined $name;

	       my $decription = $kv->getValue('description');


	       if (defined $variantof) {
		 die "$macroStr is variant of $variantofStr, but $variantofStr was not defined"
		   if !defined $macroToCDName{$variantofStr};
		 my $mainentry = $declarations{$macroToCDName{$variantofStr}};
		 die if defined $cd;
		 die if defined $name;
		 $cd = $$mainentry{cd};
		 $name = $$mainentry{name};
	       }

	       if ($variable) {
		 if (defined $cd) { die "Must not define cd=... when variable=true"; };
		 $cd = 'variable';
		 if (!defined $name) {
		   $name = $macroStr;
		   $name =~ s/\\//g;
		 }
		 $name = uniqueName($name);
	       }

	       # Defaults:
	       $cd = 'local' if not defined $cd;
	       if (not defined $name) {
		 $name = $macroStr;
		 $name =~ s/\\//g; }

	       my $cdname = $cd.".".$name;

	       # Define macro
	       if (defined $code) {
		 my ($numargs,$optarg) = (0,undef);
		 if ($argspec ne '') {
		   ($numargs,$optarg) = ($argspec =~ m/^\[([0-9]+)\](\[.*\])?$/)
		     or die "Could not parse argspec ".Dumper($argspec);
		 }
		 my $paramspec = convertLaTeXArgs($numargs,$optarg);
		 if ($cd eq 'variable') {
		   DefMathI($macro,$paramspec,$code, name=>$name);
		 } else {
		   DefMathI($macro,$paramspec,$code, omcd=>$cd, meaning=>$name);
		 }
	       } else {
		 die "argspec=$argspec given, but code=... not given" if defined $argspec;
	       };



	       # Create symbol index entry
	       if (!defined $variantof) {
		 die "No description for ".ToString($macro) if (!defined $description);
		 die "No placeholder for ".ToString($macro) if (!defined $placeholder);

		 die "Duplicate declaration for $cdname: ".ToString($macro)." vs ".ToString($declarations{$cdname}->{macro})
		   if defined $declarations{$cdname};

		 $declarations{$cdname} = { placeholder => $placeholder,
					    description => $description,
					    cd => $cd,
					    name => $name,
					    macro => $macro,
					    symbolindexmarks => [] };
		 $macroToCDName{$macroStr} = $cdname;
	       }

	       return;
	     });

DefConstructorI('\declMath@DefRef','{}',
		"<ltx:ref class='declMathDefRef' labelref='LABEL:#1'>\x{feff}</ltx:ref>");


DefPrimitiveI('\printsymbolindex',undef, sub {
		my @result = ();
		push @result, Digest(T_COMMENT("SYMBOL INDEX"));
		for my $decl (values %declarations) {
		  my $refs = Tokens(map { Invocation(T_CS('\declMath@DefRef'),$_) } @{$decl->{symbolindexmarks}});
		  push @result, Digest(Invocation(T_CS('\@@@declmath@internal@xmlinfo'),
						  "$$decl{cd}.$$decl{name}",
						  Tokens(T_MATH,T_SPACE,$$decl{placeholder},T_MATH),
						  $$decl{description},
						  $refs));
		};
		return @result;
	      });

DefConstructorI('\declmath@labelhere','{}', '<ltx:inline-itemize><ltx:inline-item labels="LABEL:#1"><ltx:tag/></ltx:inline-item></ltx:inline-itemize>');

DefMacroI('\symbolindexmark','{}',sub {
	    my ($gullet,$macro) = @_;
	    my $macroStr = ToString($macro);
	    my $cdname = $macroToCDName{$macroStr};
	    die "Undeclared math macro $macroStr" unless defined $cdname;
	    my $label = uniqueName("symbolindexmark:$cdname");
	    my $decl = $declarations{$cdname};
	    push @{$decl->{symbolindexmarks}}, $label;
	    return Invocation(T_CS('\declmath@labelhere'),$label);
	  });

1;

