# -*- mode: perl; -*-

use LaTeXML::Package;
use strict;
use warnings;

use Data::Dumper qw/Dumper/;

RequirePackage('hyperref');

our %macroToCDName = ();
our %declarations = ();

our %uniqueNames = ();
sub uniqueName {
  my ($name) = @_;
  if (!defined $uniqueNames{$name}) {
    $uniqueNames{$name} = 1;
    return $name;
  }
  for (my $i = 1; ; $i++) {
    my $name1 = $name.$i;
    if (!defined $uniqueNames{$name1}) {
      $uniqueNames{$name1} = 1;
      return $name1;
    }
  }
}

RequireResource('declmath.css');
RequireResource('https://code.jquery.com/jquery-3.2.1.min.js');
RequireResource('declmath.js');

DefKeyVal('declare@keyval','macro','DefToken');
DefKeyVal('declare@keyval','argspec','{[Number][]}');
DefKeyVal('declare@keyval','code','');
DefKeyVal('declare@keyval','variantof','');

DefConstructorI('\@@@declmath@internal@xmlinfo','{}{}{}{}', sub {
 		  my ($document,$cdname,$placeholder,$description,$symbolindexlinks) = @_;
		  my $id = "symbolindexentry-".ToString($cdname);
 		  $document->openElement('ltx:para','xml:id'=>$id,'class'=>'symbolIndexEntry');
 		  $document->insertElement('ltx:p',$placeholder);
 		  $document->insertElement('ltx:p',$description);
 		  $document->insertElement('ltx:p',$symbolindexlinks);
 		  $document->closeElement('ltx:para');
 		});


DefPrimitive('\declare RequiredKeyVals:declare@keyval', sub {
	       my ($stomach, $kv) = @_;
	       my $macro = $kv->getValue('macro');
	       my $macroStr = ToString($macro);
	       my $argspec = ToString($kv->getValue('argspec'));
	       my $code = $kv->getValue('code');
	       my $placeholder = $kv->getValue('placeholder');
	       if (!defined $placeholder and $argspec eq '') {
		 $placeholder = $macro; }
	       my $description = $kv->getValue('description');
	       my $variantof = $kv->getValue('variantof');
	       my $variantofStr = ToString($variantof);

	       # TODO: use from declaration if available
	       my $cd = undef;
	       my $name = undef;

	       my $decription = $kv->getValue('description');


	       if (defined $variantof) {
		 die "$macroStr is variant of $variantofStr, but $variantofStr was not defined"
		   if !defined $macroToCDName{$variantofStr};
		 my $mainentry = $declarations{$macroToCDName{$variantofStr}};
		 die if defined $cd;
		 die if defined $name;
		 $cd = $$mainentry{cd};
		 $name = $$mainentry{name};
	       }

	       # Defaults:
	       $cd = 'undeclared' if not defined $cd;
	       if (not defined $name) {
		 $name = $macroStr;
		 $name =~ s/\\//g; }


	       my $cdname = $cd.".".$name;

	       # Define macro
	       my ($numargs,$optarg) = (0,undef);
	       if ($argspec ne '') {
		 ($numargs,$optarg) = ($argspec =~ m/^\[([0-9]+)\](\[.*\])?$/)
		   or die "Could not parse argspec ".Dumper($argspec);
	       }
	       my $paramspec = '{}' x $numargs;
	       $paramspec = '[Default:$optarg]' if defined $optarg;
	       DefMathI($macro,convertLaTeXArgs($numargs,$optarg),$code,
			omcd=>$cd, meaning=>$name);




	       # Create symbol index entry
	       if (!defined $variantof) {
		 die "No description for ".ToString($macro) if (!defined $description);
		 die "No placeholder for ".ToString($macro) if (!defined $placeholder);

		 die "Duplicate declaration for $cdname: ".ToString($macro)." vs ".ToString($declarations{$cdname}->{macro})
		   if defined $declarations{$cdname};

		 $declarations{$cdname} = { placeholder => $placeholder,
					    description => $description,
					    cd => $cd,
					    name => $name,
					    macro => $macro,
					    symbolindexmarks => [] };
		 $macroToCDName{$macroStr} = $cdname;
	       }

	       return;
	     });

DefPrimitiveI('\printsymbolindex',undef, sub {
		my @result = ();
		push @result, Digest(T_COMMENT("SYMBOL INDEX"));
		for my $decl (values %declarations) {
		  my $refs = Tokens(map { Invocation(T_CS('\htmlref'),'[X]',$_) } @{$decl->{symbolindexmarks}});
		  push @result, Digest(Invocation(T_CS('\@@@declmath@internal@xmlinfo'),
						  "$$decl{cd}.$$decl{name}",
						  Tokens(T_MATH,T_SPACE,$$decl{placeholder},T_MATH),
						  $$decl{description},
						  $refs));
		};
		return @result;
	      });

DefConstructorI('\declmath@labelhere','{}', '<ltx:inline-itemize><ltx:inline-item labels="LABEL:#1"><ltx:tag/></ltx:inline-item></ltx:inline-itemize>');

DefMacroI('\symbolindexmark','{}',sub {
	    my ($gullet,$macro) = @_;
	    my $macroStr = ToString($macro);
	    my $cdname = $macroToCDName{$macroStr};
	    die "Undeclared math macro $macroStr" unless defined $cdname;
	    my $label = uniqueName("symbolindexmark:$cdname");
	    my $decl = $declarations{$cdname};
	    push @{$decl->{symbolindexmarks}}, $label;
	    return Invocation(T_CS('\declmath@labelhere'),$label);
	  });

1;

